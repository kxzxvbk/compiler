# 语义分析+代码生成

## 编码前设计

​        这次的作业分为两个难度，一个是生成四元式进而生成mips汇编，另一个是生成栈式虚拟机的pcode。这两个中，pcode易于生成，但是四元式方便进一步的化简。我选择了四元式。

​        但是在设计的时候，我意识到，如果采用直接生成四元式的方法，那么势必造成这样一个问题：语法分析程序要引入大量变量命名的代码，会显得非常臃肿，既不利于工程化管理，也会加大开发难度。但是又因为pcode和四元式是可以相互转化的。所以，为了生成的便捷性，我采用了pcode作为中间过渡，然后再统一地分配中间变量名称生成四元式。举例说明如下：

对于表达式y = a + b*c

先化成pcode：

```pseudocode
LOD a
LOD b
LOD c
MULT
ADD
ASSIGN y
```

​        然后加上中间变量, 从而变成四元式（这个步骤实际上就是在编译器中，建立了一个符号栈）：

```c++
t1 = a
t2 = b
t3 = c
t4 = t2 * t3
t5 = t4 + t2
y = t5
```

这样的好处是：将比较复杂的、有关中间变量生成的代码从语法分析程序中剥离开来，简化编码难度。

### 重点部分设计

#### 内存分配

​        对于内存分配的问题，我的方法是：将全局变量放置于.data段；将程序中的临时变量放在运行栈，通过移动$sp的方式完成函数调用和返回，切换上下文。

#### 符号表管理

​        由于生成了大量的中间变量，所以我重新在编译器中建立了符号表。但是这个符号表可以比较精简，它包括了如下内容：变量名称，所有变量的地址（相对于$sp, 或.data基址的偏移量），是不是全局变量，是不是常量const，以及如果是常量的话它的值是多少。

​        值得一提的是，对于变量名称的命名应该比较注意，一定要避免出现和程序中变量重名的情况，我的命名规则是：对于程序中出现的变量VAR，假设它在函数FUNC中，则命名为@FUNC_@Usr_VAR；如果是全局变量则命名为@Usr_VAR；如果是编译器分配的临时变量ti，则命名为@FUNC_ti

#### 函数调用

#####         caller

```
...
subi $sp, $sp, SPACE_LENGTH
<push parameters>
jal CALLEE
addi $sp, $sp, SPACE_LENGTH
lw $ra, 0($sp)
...
```

​        其中SPACE_LENGTH指的是，CALLEE中所有变量总共需要的空间大小

#####         callee

```
sw $ra, 0($sp)
...
SET $v0           # if return value exists
jal $ra
...
```

#### 寄存器分配

​        本次作业为了方便起见，不做寄存器优化处理，所有的运算都在$t0, $t1, $t2中完成。

## 编码后设计

这里列出对之前设计的补充：

- 有两个问题导致不必要的开销：

​        1、对于y = a + b这种形式的代码，事实上我又开辟了t1, t2的内存空间，这是不必要的。因此可以设置t1指向a的内存空间，t2指向b的内存空间。

​        2、对于y = 1 + 2这种形式的代码，我对立即数也开辟了内存空间，这同样是不必要的。因此可以将t1，t2认为是const类型的常量，从而避免计算。

- 对于字符串的存储，我一开始想到的方法是：如果遇到需要print字符串时，那么就在$sp之下（这一段显然是空闲区域，可以随意使用）开辟临时的空间，存入字符串并且打印，输出结束后不做处理即可。但是这样会导致非常大量的内存访问时间开销，所以不妨全部将字符串存储至.data段，做静态的空间分配。

- 函数调用参数的选择：

  如果出现push语句，不要急着做，而是应该把它暂时存到一个栈里（称作PUSH_STACK）；等到call指令到来的时候，再从PUSH_STACK中取出相应数量的push指令进行压栈操作。如：

  FUNC1（VAR1, FUNC2(VAR2)）如果按照简单的顺序，应该是     

```
push VAR1
push VAR2
call FUNC2
VAR3 = RETURN_VAL of FUNC2
push VAR3
call FUNC1
```

​       但这样会导致错误，VAR1其实不能那么早push进去。因为VAR1被push之后存储的位置是在当前$sp之下，而一旦调用了FUNC2，这块区域很可能被FUNC2写乱；再次调用FUNC1时，可能就没有正确结果了。因此，正确顺序应该是

```
push VAR2
call FUNC2
VAR3 = RETURN_VAL of FUNC2
push VAR1
push VAR3
call FUNC1
```

- 字符串不要转义